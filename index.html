<!DOCTYPE html>
<html>

<head>
	<meta charset='utf-8'>
	<title>Cargo-specification</title>
	<script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
	<script class='remove'>
		async function loadRust() {
			//this is the function you call in 'preProcess', to load the highlighter
			const worker = await new Promise(resolve => {
				require(["core/worker"], ({ worker }) => resolve(worker));
			});
			const action = "highlight-load-lang";
			const langURL =
				"https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/d8a7057fe9c7140f7ef5972b333716d9933fa29b/hljs-rust.js";
			const propName = "hljsDefineRust"; // This funtion is defined in the highlighter being loaded
			const lang = "rust"; // this is the class you use to identify the language
			worker.postMessage({ action, langURL, propName, lang });
			return new Promise(resolve => {
				worker.addEventListener("message", function listener({ data }) {
					const { action: responseAction, lang: responseLang } = data;
					if (responseAction === action && responseLang === lang) {
						worker.removeEventListener("message", listener);
						resolve();
					}
				});
			});
		}


		async function loadProto() {
			//this is the function you call in 'preProcess', to load the highlighter
			const worker = await new Promise(resolve => {
				require(["core/worker"], ({ worker }) => resolve(worker));
			});
			const action = "highlight-load-lang";
			const langURL =
				"https://gistcdn.githack.com/mimoo/a9e28fc565dddb369477e8bd34e6a1ae/raw/555beea7387129c657c49d8616b778c67629b586/hljs-proto.js";
			const propName = "hljsDefineProto"; // This funtion is defined in the highlighter being loaded
			const lang = "proto"; // this is the class you use to identify the language
			worker.postMessage({ action, langURL, propName, lang });
			return new Promise(resolve => {
				worker.addEventListener("message", function listener({ data }) {
					const { action: responseAction, lang: responseLang } = data;
					if (responseAction === action && responseLang === lang) {
						worker.removeEventListener("message", listener);
						resolve();
					}
				});
			});
		}

		var respecConfig = {
			preProcess: [loadRust, loadProto],
			specStatus: "base",
			editors: [
				// 
				{
					name: "David Wong",
					url: "",
				},
				// 
			],
			github: "",
			shortName: "",
			//			format: "markdown",
		};
	</script>
</head>

<body>
	<section id="abstract">This specification describes how the command-line utility cargo-specification works.</section>

	<h1>Cargo-specification</h1>
<p>author: David Wong</p>
<h2>overview</h2>
<p>Building a specification is pretty straight forward. Cargo-spec follows these steps:</p>
<ol>
<li>parse the specification file with the <a href="#toml-parser">toml_parser</a></li>
<li>retrieve the template file</li>
<li>extract the spec comments from all the files listed using <a href="#comment-parser">comment_parser</a></li>
<li>render the template</li>
<li>build the spec. We currently support two different formats:</li>
</ol>
<ul>
<li><a href="https://daringfireball.net/projects/markdown/">markdown</a></li>
<li><a href="https://github.com/w3c/respec/">respec</a></li>
</ul>
<h2>Toml parser</h2>
<p>The toml parser expects a manifest specification file that follows the following configuration:</p>
<pre lang="rs"><code>/// A specification file contains a specification, as well as sections of (title, text)
#[derive(Serialize, Deserialize, Debug)]
pub struct Specification {
    /// information about a specification
    pub metadata: Metadata,
    /// configuration of the specification
    pub config: Config,
    /// files to use for the specification's content
    pub sections: HashMap&lt;String, String&gt;,
}

#[derive(Serialize, Deserialize, Debug)]
pub struct Config {
    /// main template file
    pub template: String,
}

/// Metadata about a specification
#[derive(Serialize, Deserialize, Debug)]
pub struct Metadata {
    /// Name of the specification
    pub name: String,
    /// A description
    pub description: Option&lt;String&gt;,
    /// Version of the spec
    pub version: Option&lt;String&gt;,
    /// Authors, if any
    pub authors: Vec&lt;String&gt;,
}
</code></pre>
<p>The structures are deserialized using the <a href="https://github.com/toml-lang/toml">toml encoding</a>.</p>
<h2>Comment parser</h2>
<p>Any placeholder in the template will get replaced by comments extracted from code.
The specification manifest file contains the list of these files.</p>
<p>parsing is based on the extension of the file:</p>
<ul>
<li>for markdown files, we retrieve the entire content</li>
<li>for python files we look for comments starting with <code>#~</code></li>
<li>for ML files we look for comments starting with <code>#~</code></li>
<li>for other files we look for comments starting with <code>//~</code></li>
</ul>
<p>for each file listed by the specification manifest, we follow these steps:</p>
<ol>
<li>only print a normal line if it is between <code>//~ spec:startcode</code> and <code>//~spec:endcode</code> statements</li>
<li>if we are within a multi-line comment, we remove the indentation
based on the indentation of the first line of the comment</li>
<li>otherwise, we extract what comes after the comment delimiter
(note that the result might still have a starting space)</li>
<li>lines starting with <code>//~ spec:</code> are specific instructions:
<ul>
<li>a comment starting with <code>//~ spec:startcode</code> will print
every line afterwards, up until a <code>//~ spec:endcode</code> statement</li>
<li>error on any other instructions</li>
</ul>
</li>
<li>if we are not seeing an instruction, figure out if:
<ul>
<li>the comment is ending</li>
<li>or goes on to the next line</li>
</ul>
</li>
<li>Finally, extract the specification text.
Each <code>~</code> at the start of the comment,
not including the first one,
is converted to a tab.
This allows us to write <code>//~~ *</code> for nested list items.</li>
<li>at the end, make sure that every startcode instruction
is matched with a endcode instruction</li>
<li>return the result</li>
</ol>


</body>

</html>